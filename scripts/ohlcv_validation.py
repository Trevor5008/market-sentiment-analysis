from __future__ import annotations

import argparse
from pathlib import Path
from typing import Dict, Any
import numpy as np
import pandas as pd
import pandas_market_calendars as mcal

def get_project_root() -> Path:
    """Find project root by locating this script and going up one level."""
    script_dir = Path(__file__).parent.resolve()
    # If script is in scripts/, go up one level to project root
    if script_dir.name == "scripts":
        return script_dir.parent
    # Otherwise, assume we're already at project root
    return script_dir

REQUIRED_COLS = ["date", "open", "high", "low", "close", "adj_close", "volume", "ticker"]
NUMERIC_COLS = ["open", "high", "low", "close", "adj_close", "volume"]

def load_data(path: Path) -> pd.DataFrame:
    df = pd.read_csv(path)
    df["date"] = pd.to_datetime(df["date"], errors="coerce")
    for col in NUMERIC_COLS:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")
    return df

def validate_schema(df: pd.DataFrame) -> dict:
    cols = set(df.columns)
    missing = [c for c in REQUIRED_COLS if c not in cols]
    extra = [c for c in df.columns if c not in REQUIRED_COLS]
    return {"missing_required": missing, "extra_columns": extra}

def mad_zscore(x: pd.Series) -> pd.Series:
    x = x.dropna().astype(float)
    if len(x) < 2:
        return pd.Series(np.nan, index=x.index)
    med = np.median(x)
    mad = np.median(np.abs(x - med))
    if mad == 0:
        return pd.Series(0.0, index=x.index)
    return (x - med) / (1.4826 * mad)

def get_expected_trading_days(start, end, exchange='NYSE'):
    """Fetch valid trading dates for a specific exchange using market calendars."""
    try:
        cal = mcal.get_calendar(exchange)
        schedule = cal.schedule(start_date=start, end_date=end)
        return pd.DatetimeIndex(schedule.index).tz_localize(None)
    except Exception:
        # Fallback to business days if exchange is invalid
        return pd.date_range(start, end, freq='B')

def summarize_ohlcv(df: pd.DataFrame, exchange: str = "NYSE") -> dict:
    stats = {
        "rows": int(len(df)),
        "tickers": int(df["ticker"].nunique()) if "ticker" in df.columns else 0,
        "date_min": df["date"].min(),
        "date_max": df["date"].max(),
        "logical_errors": 0,
        "outliers_found": 0,
        "missing_trading_days": 0,
        "missing_values": df[REQUIRED_COLS].isna().sum().to_dict() if all(c in df.columns for c in REQUIRED_COLS) else {}
    }

    if not df.empty and "ticker" in df.columns and "date" in df.columns:
        # 1. Logical Constraints
        logical_mask = (
            (df["high"] < df["open"]) | 
            (df["high"] < df["close"]) | 
            (df["low"] > df["open"]) | 
            (df["low"] > df["close"]) |
            (df["high"] < df["low"])
        )
        stats["logical_errors"] = int(logical_mask.sum())

        # 2. Market Calendar Check (Missing Days)
        expected_days = get_expected_trading_days(stats["date_min"], stats["date_max"], exchange)
        actual_days = pd.DatetimeIndex(df["date"].unique())
        stats["missing_trading_days"] = len(expected_days.difference(actual_days))

        # 3. Outlier Detection
        outlier_total = 0
        for _, tdf in df.groupby("ticker"):
            tdf = tdf.sort_values("date")
            log_ret = np.log(tdf["close"]).diff()
            z_scores = mad_zscore(log_ret)
            outlier_total += (z_scores.abs() > 8.0).sum()
        stats["outliers_found"] = int(outlier_total)

    return stats

def to_markdown_report(input_path: Path, schema: dict, stats: dict, exchange: str) -> str:
    lines = [
        "# OHLCV Data Validation Report",
        f"\n**Input File:** `{input_path.as_posix()}`",
        f"**Market Calendar:** `{exchange}`",
        "\n## Dataset Overview",
        f"- Total Rows: **{stats['rows']}**",
        f"- Unique Tickers: **{stats['tickers']}**",
        f"- Date Range: `{stats['date_min'].date()}` to `{stats['date_max'].date()}`",
        "\n## Schema Validation",
        f"- Missing Columns: `{schema['missing_required']}`",
        f"- Extra Columns: `{schema['extra_columns']}`",
        "\n## Data Integrity Issues",
        f"- **Logical Price Errors:** {stats['logical_errors']}",
        f"- **Missing Trading Days (Holidays Accounted):** {stats['missing_trading_days']}",
        f"- **Price Outliers (MAD > 8.0):** {stats['outliers_found']}",
        "\n## Missing Values Count"
    ]
    for col, count in stats["missing_values"].items():
        lines.append(f"- {col}: {count}")
    
    lines.append("\n---\n*Report generated by OHLCV Validation Script*")
    return "\n".join(lines)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--input", default="data/raw/prices_daily.csv")
    parser.add_argument("--out", default="docs/validation/ohlcv_validation.md")
    parser.add_argument("--exchange", default="NYSE", help="Exchange calendar to use (e.g., NYSE, LSE, JPX)")
    args = parser.parse_args()

    project_root = get_project_root()
    input_path = (project_root / args.input).resolve()
    out_path = (project_root / args.out).resolve()
    out_path.parent.mkdir(parents=True, exist_ok=True)

    if not input_path.exists():
        raise FileNotFoundError(f"Missing input file: {input_path}")

    df = load_data(input_path)
    schema = validate_schema(df)
    stats = summarize_ohlcv(df, exchange=args.exchange)

    report = to_markdown_report(input_path, schema, stats, args.exchange)
    out_path.write_text(report, encoding="utf-8")

    print(f"[OK] Processed {stats['rows']:,} rows using {args.exchange} calendar")
    print(f"[OK] Report saved to -> {out_path}")

    if stats["rows"] == 0 or len(schema["missing_required"]) > 0:
        raise SystemExit(2)

if __name__ == "__main__":
    main()